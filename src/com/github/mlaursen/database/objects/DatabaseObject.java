package com.github.mlaursen.database.objects;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.github.mlaursen.annotations.DatabaseField;
import com.github.mlaursen.annotations.DatabaseFieldType;
import com.github.mlaursen.annotations.MultipleDatabaseField;
import com.github.mlaursen.database.DatabaseObjectClassUtil;

/**
 * Basic outline for a DatbaseObject. Every database object must have at least a
 * primary key
 * 
 * @author mikkel.laursen
 * 
 */
public abstract class DatabaseObject {

	@DatabaseField(values = { DatabaseFieldType.GET, DatabaseFieldType.DELETE, DatabaseFieldType.UPDATE })
	protected String primaryKey;
	protected String primaryKeyName = "id";

	public DatabaseObject() { }
	public DatabaseObject(String primaryKey) {
		this.primaryKey = primaryKey;
	}
	
	/**
	 * Sets the primary key to the database column described as the
	 * primaryKeyName. The default is 'id'
	 * 
	 * @param r
	 */
	public DatabaseObject(MyResultRow r) {
		if(r.get(primaryKeyName) != null)
			setAll(r);
	}

	/**
	 * This finds all the methods that start with 'set' and have a single
	 * parameter of a MyResultRow and then invokes that method.
	 * 
	 * @param r
	 */
	protected void setAll(MyResultRow r) {
		Method[] methods = this.getClass().getMethods();
		for (Method m : methods) {
			if (m.getName().startsWith("set") && Arrays.asList(m.getParameterTypes()).contains(MyResultRow.class) && r != null) {
				try {
					m.setAccessible(true);
					m.invoke(this, r);
					m.setAccessible(false);
				}
				catch (InvocationTargetException | IllegalAccessException | IllegalArgumentException e) {
					System.err.println("There was a problem trying to invoke " + m.getName());
				}
			}
		}
	}

	/**
	 * 
	 * @param primaryKey
	 */
	public void setPrimaryKey(String primaryKey) {
		this.primaryKey = primaryKey;
	}

	/**
	 * 
	 * @param primaryKey
	 */
	public void setPrimaryKey(Integer primaryKey) {
		this.primaryKey = primaryKey.toString();
	}

	/**
	 * Sets the primary key to the database column described as the
	 * primaryKeyName. The default is 'id'
	 * 
	 * @param r
	 */
	public void setPrimaryKey(MyResultRow r) {
		primaryKey = r.get(primaryKeyName);
	}

	/**
	 * Get the primaryKey value
	 * 
	 * @return
	 */
	public String getPrimaryKey() {
		return primaryKey;
	}

	/**
	 * Set the primary key name to the new string given. This will be used for
	 * initializing a database object
	 * 
	 * @param name
	 */
	public void setPrimaryKeyName(String name) {
		primaryKeyName = name;
	}

	/**
	 * Returns the primary key name for the database object. The default is 'id'
	 * 
	 * @return
	 */
	public String getPrimaryKeyName() {
		return primaryKeyName;
	}

	/**
	 * Get an array of Object to be passed to a database procedure call. The
	 * array is generated by seraching for all the DatabaseField or
	 * MultipleDatabaseField annotations located in the class starting with the
	 * DatabaseObject and working down to the current class.
	 * 
	 * @param proc
	 *            The procedure to get the parameters for
	 * @return
	 */
	private Object[] getParameters(DatabaseFieldType proc) {
		return getParameters(getParametersMap(proc));
	}

	/**
	 * Takes a Map of interger position and objects and sorts them from 0 - max
	 * size of map into an array of objects
	 * 
	 * @param map
	 * @return
	 */
	private Object[] getParameters(Map<Integer, Object> map) {
		int s = map.size();
		Object[] ps = new Object[s];
		for (int i = 0; i < s; i++) {
			ps[i] = map.get(i);
		}
		return ps;
	}

	/**
	 * Takes in a DatabaseFieldType and generates a Map of Integer, Object pairs
	 * to be passed to the database stored procedure.
	 * 
	 * @param proc
	 * @return
	 */
	private Map<Integer, Object> getParametersMap(DatabaseFieldType proc) {
		int counter = 0;
		Map<Integer, Object> params = new HashMap<Integer, Object>();
		List<Class<?>> classes = DatabaseObjectClassUtil.getClassList(this.getClass());
		for (Class<?> c : classes) {
			for (Field f : c.getDeclaredFields()) {
				f.setAccessible(true);
				if(f.isAnnotationPresent(MultipleDatabaseField.class)) {
					MultipleDatabaseField a = f.getAnnotation(MultipleDatabaseField.class);
					if(Arrays.asList(a.values()).contains(proc)) {
						for(String n : a.names()) {
							try {
								Object o = f.get(this);
								Class<?> oClass = o.getClass();
								String oClassName = oClass.getSimpleName();
								String searchName = n.substring(oClassName.length());
								for(Method m : oClass.getMethods()) {
									String mName = m.getName();
									if(mName.startsWith("get") && mName.matches("(?i)get" + searchName)) {
										Object ret = m.invoke(o);
										params.put(counter, ret);
										counter++;
									}
								}
							}
							catch (IllegalArgumentException | IllegalAccessException e) {
								e.printStackTrace();
							}
							catch (Exception e) {
								String err = "The position for the procedure '" + proc + "' has not been initialized for the field " + "["
										+ f.getName() + "]\nin class [" + c.getName() + "].  This error occured when seraching for the values "
										+ "to add when calling the stored procedure. The value has not been added to the parameter map.";
								System.err.println(err);
							}
						}
					}
				}
				else if (f.isAnnotationPresent(DatabaseField.class)) {
					DatabaseField a = f.getAnnotation(DatabaseField.class);
					if (Arrays.asList(a.values()).contains(proc)) {
						try {
							Object o = f.get(this);
							int pos = a.reorder() ? DatabaseFieldType.getPosition(proc, a) : counter;
							counter++;
							if (pos == -1) {
								throw new Exception();
							}
							else {
								params.put(pos, o);
							}
						}
						catch (IllegalArgumentException | IllegalAccessException e) {
							e.printStackTrace();
						}
						catch (Exception e) {
							String err = "The position for the procedure '" + proc + "' has not been initialized for the field " + "["
									+ f.getName() + "]\nin class [" + c.getName() + "].  This error occured when seraching for the values "
									+ "to add when calling the stored procedure. The value has not been added to the parameter map.";
							System.err.println(err);
						}
					}
				}
				f.setAccessible(false);
			}
		}
		return params;
	}
	
	public List<Procedure> getCustomProcedures() {
		return new ArrayList<Procedure>();
	}
	
	/**
	 * This is a basic check for if a Database object equals another.
	 * It just checks if the primary Key values are equal.
	 * @param o The object to compare to
	 */
	@Override
	public boolean equals(Object o) {
		return (o instanceof DatabaseObject) && primaryKey.equals(((DatabaseObject) o).primaryKey);
	}

	/**
	 * This is the default toString
	 */
	@Override
	public String toString() {
		return "DatabaseObject [primaryKey=" + primaryKey + ", primaryKeyName=" + primaryKeyName + "]";
	}
}
